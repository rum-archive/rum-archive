<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/css/main.css" />
  <script src="/js/main.js"></script>
  <title>RUM Archive - RUM Insights</title>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#006a80">
  <meta name="msapplication-TileColor" content="#006a80">
  <meta name="theme-color" content="#006a80">

  <!-- Facebook Meta Tags -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="RUM Archive - RUM Insights">
  <meta property="og:image" content="https://rumarchive.com/assets/rum-archive-banner-facebook-1200x630.png">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:domain" content="rumarchive.com">
  <meta name="twitter:title" content="RUM Archive - RUM Insights">
  <meta name="twitter:image" content="https://rumarchive.com/assets/rum-archive-banner-twitter-1600x900.png">

  <link rel="feed alternate" type="application/atom+xml" href="/blog/feed.xml" title="Atom Feed">

  <script>(function(){if(window.BOOMR&&(window.BOOMR.version||window.BOOMR.snippetExecuted)){return}window.BOOMR=window.BOOMR||{};window.BOOMR.snippetStart=(new Date).getTime();window.BOOMR.snippetExecuted=true;window.BOOMR.snippetVersion=15;window.BOOMR.url="//c.go-mpulse.net/boomerang/S4RHZ-UABWM-G9DGN-GKRY7-DUGEG";var e=document.currentScript||document.getElementsByTagName("script")[0],a=e.parentNode,s=false,t=3e3;function n(){if(s){return}var e=document.createElement("script");e.id="boomr-scr-as";e.src=window.BOOMR.url;e.async=true;a.appendChild(e);s=true}function i(e){s=true;var t,i=document,n,o,d,r=window;window.BOOMR.snippetMethod=e?"if":"i";n=function(e,t){var n=i.createElement("script");n.id=t||"boomr-if-as";n.src=window.BOOMR.url;BOOMR_lstart=(new Date).getTime();e=e||i.body;e.appendChild(n)};if(!window.addEventListener&&window.attachEvent&&navigator.userAgent.match(/MSIE [678]\./)){window.BOOMR.snippetMethod="s";n(a,"boomr-async");return}o=document.createElement("IFRAME");o.src="about:blank";o.title="";o.role="presentation";o.loading="eager";d=(o.frameElement||o).style;d.width=0;d.height=0;d.border=0;d.display="none";a.appendChild(o);try{r=o.contentWindow;i=r.document.open()}catch(e){t=document.domain;o.src="javascript:var d=document.open();d.domain='"+t+"';void 0;";r=o.contentWindow;i=r.document.open()}r._boomrl=function(){n()};if(r.addEventListener){r.addEventListener("load",r._boomrl,false)}else if(r.attachEvent){r.attachEvent("onload",r._boomrl)}i.close()}var o=document.createElement("link");if(o.relList&&typeof o.relList.supports==="function"&&o.relList.supports("preload")&&"as"in o){window.BOOMR.snippetMethod="p";o.href=window.BOOMR.url;o.rel="preload";o.as="script";o.addEventListener("load",n);o.addEventListener("error",function(){i(true)});setTimeout(function(){if(!s){i(true)}},t);BOOMR_lstart=(new Date).getTime();a.appendChild(o)}else{i(false)}function d(e){window.BOOMR_onload=e&&e.timeStamp||(new Date).getTime()}if(window.addEventListener){window.addEventListener("load",d,false)}else if(window.attachEvent){window.attachEvent("onload",d)}})();</script>
</head>
<body>
  <header><nav class="navbar is-light" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="/">
      <img src="/assets/rum-archive-logo-square.svg" width="28" height="28" />
    </a>

    <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbar-main">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>

  <div id="navbar-main" class="navbar-menu">
    <div class="navbar-start">
      <div class="navbar-item has-text-weight-bold">
        <a href="/">RUM Archive</a>
      </div>
    </div>

    <div class="navbar-end">
      <div class="navbar-item has-dropdown is-hoverable">
        <a class="navbar-link" href="/docs/">
          Documentation
        </a>

        <div class="navbar-dropdown">
          <a class="navbar-item" href="/docs/methodology">
            Methodology
          </a>
          <a class="navbar-item" href="/docs/querying">
            Querying
          </a>
          <a class="navbar-item" href="/docs/tables">
            Tables
          </a>
          <a class="navbar-item" href="/docs/samples">
            Samples
          </a>
          <a class="navbar-item" href="/docs/tips">
            Tips
          </a>
          <a class="navbar-item" href="/docs/release-notes">
            Release  Notes
          </a>
        </div>
      </div>

      <a href="/datasets" class="navbar-item">
        Datasets
      </a>

      <a href="/blog" class="navbar-item">
        Blog
      </a>

      <a href="/insights" class="navbar-item">
        Insights
      </a>

      <a href="/contribute" class="navbar-item">
        Contribute!
      </a>

      <a href="https://github.com/rum-archive/rum-archive" class="navbar-item">
        Github
      </a>

      <a href="/about" class="navbar-item">
        About
      </a>
    </div>
  </div>
</nav>
</header>
  <main>
    
<article class="page-layout">
  <div class="container">
    <div class="columns">
      <div class="column is-10 is-offset-1">
        <div class="content m-5">
          <h1>RUM Insights</h1>
          
            <h2>Table of Contents</h2>
            <aside>
              <div class="toc" >
        <ul><li><a href="#marketshares">Market Shares</a><ul><li><a href="#device-marketshare">Device Type</a></li><li><a href="#os-marketshare">Operating System</a></li><li><a href="#ua-marketshare">Browser</a></li><li><a href="#ua-version-marketshare">Browser Versions</a></li><li><a href="#baseline"> Baseline Support</a></li></ul></li><li><a href="#navigation-aspects">Navigational Aspects</a><ul><li><a href="#navigationtype-aspect">Navigation Types</a></li><li><a href="#visibilitystate-aspect">Visibility State</a></li><li><a href="#landingpage-aspect">Landing Page</a></li><li><a href="#spa-aspect">Multi vs Single Page Apps</a></li></ul></li><li><a href="#about">About RUM Insights</a></li></ul>
      </div>
            </aside>
          
          
<h2>Introduction</h2>

<p>
This page captures a collection of basic visualizations for the data contained in the RUM Archive. 
It's goal is to allow users to get a feel for the most important insights that can be gained from the data, without having to execute SQL queries themselves.
</p>

<p>
Note that we intentionally do not include interpretations of the data here, as this can often be quite nuanced. For that, look at our <a href="/blog">regular blog posts</a> that discuss RUM Insights in depth. 
</p>


<!-- TODO: merge these into a single file --> 
<script src="/js/highcharts/highstock.js" defer></script>
<script src="/js/highcharts/exporting.js" defer></script>
<script src="/js/highcharts/export-data.js" defer></script>
<script src="/js/highcharts/accessibility.js" defer></script>

<section class="doclist mt-3 pt-3">

  <h2 id="marketshares">Market Shares</h2>

    <p>
      It is important to know which devices, operating systems and browsers your visitors are using to access your sites, as hardware power and feature support can differ widely. 
      This helps you better optimize your sites for your target audience.
    </p>

  <h3 id="device-marketshare">Device Type</h3>

    <p>
      The following graphs show the usage of different Device Types (RUM Archive currently only tracks 3 device types).
    </p> 
    
  <div class="container">
    <div id="marketshare_devicetypes" class="box">
    </div>
  </div>

  <h3 id="os-marketshare">Operating System</h3>

  <p>
    The following graphs show the usage of different Operating Systems for Desktop and Mobile devices (OSes with &lt; 1% usage share have been filtered out).
  </p> 
  <div class="container">
    <div class="columns box">
      <div class="column" id="marketshare_os_desktop">
      </div>
      <div class="column" id="marketshare_os_mobile">
      </div>
    </div>
  </div>

  <h3 id="ua-marketshare">Browser</h3>

    <p>
      The following charts show the usage of different Browsers / User Agents for Desktop and Mobile devices (entries with &lt; 1% usage share have been filtered out). 
      The data shown is from July 2nd 2024. 
    </p> 

    <div class="columns box">
      <div class="column" id="marketshare_browser_desktop">
      </div>
      <div class="column" id="marketshare_browser_mobile">
      </div>
    </div>
    
  <h3 id="ua-version-marketshare">Browser Versions</h3>

    <p>
      The following chart shows the usage of different versions of popular Browsers / User Agents for Desktop and Mobile devices. Use the dropdown to select a browser and platform. Note that User Agent parsing is done using the <a href="https://github.com/ua-parser/uap-core">ua-parser</a> library.
    </p> 
    <p>
      The data points shown are from the first and third Tuesdays of every month. 
    </p> 

    <div class="container">
      <div class="columns is-centered">
        <div class="column is-half control" style="text-align: center; vertical-align: middle;">
          <!-- <label class="label" for="marketshare_browser_version_select">Select browser:</label> -->
          <div class="select">
            <select id="marketshare_browser_version_select">
            </select>
          </div>
        </div>
      </div>
      <div id="marketshare_browser_version" class="box">
      </div>
    </div>  

    <h3 id="baseline"><img src="/assets/baseline-logo.png" style="width: 80px; padding-right: 10px; vertical-align: middle;" /> Baseline Support</h3>

    <p>
      The <a href="https://web.dev/baseline">Web Platform Baseline project</a> aims to track 
      when exactly Web features became available in all major browsers (Chrome, Edge, Firefox, Safari).
      This is important since not all browsers implement all features at the same time; 
      using cutting edge feature X on browser A might mean you leave some of your users on browser B out in the cold (or having to implement a costly fallback).

    </p>

    <p>
      However, you also don't want to only use features from Baseline 2017, "just to be safe", 
      because that would mean missing out on many already widely available features. 
      In practice, you want to utilize features that <b>almost all of your users</b> will benefit from.
      To help you figure out which features those are and which Baseline year you should target, 
      below we show how many global visitors observed by the RUM Archive <b>on the first Tuesday of April 2024</b> 
      had support for ALL the features in a particular Baseline year.
    </p>

    <style>
      .table.is-hoverable tbody tr:not(.is-selected):hover {
        cursor: pointer;
      }

      .usageDisclaimerIcon {
        cursor: pointer;
        width: 15px;
      }

      ul.features-list {
        margin-left: 1em;
      }

      .features-list li {
          list-style: none;
          padding: 2px 40px;
          background-image: url("/assets/baseline-blue-logo.svg");
          background-repeat: no-repeat;
          background-position: left center;
          background-size: 30px;
      }
    </style>

    <div class="container">
      <div id="baseline_desktop" class="box">
        <h3>Baseline support Desktop</h3>
        <div class="columns">
          <div class="column is-one-third">
            <table id="baseline_desktop_table" class="table is-hoverable">
              <thead>
                <tr style="text-align: center;">
                  <th><img src="/assets/baseline-logo-text.png" style="width: 120px;" /> year</th>
                  <th>Supported by % of users of Tracked browsers <img class="usageDisclaimerIcon" onclick="showUsageDisclaimer('desktop')" src="/assets/question_mark.png" /></th>
                </tr>
              </thead>
              <tbody>
                
              </tbody>
            </table>
          </div>
          <div id="baseline_desktop_details" class="column is-two-thirds" style="padding-top: 20px;">
            <h4>Details</h4>
            <div>Click on a row in the table to get more information per Baseline year</div>
          </div>
        </div>

      </div>

      <div id="baseline_mobile" class="box">
        <h3>Baseline support Mobile</h3>
        <div class="columns">
          <div class="column is-one-third">
            <table id="baseline_mobile_table" class="table is-hoverable">
              <thead>
                <tr style="text-align: center;">
                  <th><img src="/assets/baseline-logo-text.png" style="width: 120px;" /> year</th>
                  <th>Supported by % of users of Tracked browsers <img class="usageDisclaimerIcon" onclick="showUsageDisclaimer('mobile')" src="/assets/question_mark.png" /></th>
                </tr>
              </thead>
              <tbody>
                
              </tbody>
            </table>
          </div>
          <div id="baseline_mobile_details" class="column is-two-thirds" style="padding-top: 20px;">
            <h4>Details</h4>
            <div>Click on a row in the table to get more information per Baseline year</div>
          </div>
        </div>
      </div>
    </div>

  <h2 id="navigation-aspects">Navigational Aspects</h2>

    <p>
      While for performance measurements and optimization we often focus on a full page load in its own tab (often as first page in a session) not all navigations are of course like that. 
      In this section, we explore other types of navigations and how often they occur within the RUM Archive dataset.
    </p>

    <p>
      The data shown is from July 2nd 2024.
    </p>

    <h3 id="navigationtype-aspect">Navigation Types</h3>
    
      <p>
        The following graphs show the usage of different <a href="https://techdocs.akamai.com/mpulse-boomerang/docs/whats-in-an-mpulse-beacon#top-level-fields">Navigation Types</a>. 
      </p> 

      <ul>
        <li>Navigation is a typical navigation by for example clicking on a link.</li>
        <li>Reload is when the user manually reloads the page.</li> 
        <li>Back-forward is when the user uses the back and forward buttons to navigate in their history.</li> 
      </ul>
      
      <div class="columns box">
        <div class="column" id="navigationtype_desktop">
        </div>
        <div class="column" id="navigationtype_mobile">
        </div>
      </div>

    <h3 id="visibilitystate-aspect">Visibility State</h3>

      <p>
        The following graphs show the usage of different <a href="https://techdocs.akamai.com/mpulse-boomerang/docs/whats-in-an-mpulse-beacon#visibility-state">Visibility States</a>. 
      </p> 

      <ul>
        <li>Visible typically means the user watched the page load happen.</li>
        <li>Hidden is for example when the user clicks to open the page in a new (yet hidden) tab.</li> 
        <li>Partial is when the page load starts hidden, but the user switches to the still rendering page before it's done (for example, they rapidly switch to a background tab).</li> 
      </ul>
      
    <div class="columns box">
      <div class="column" id="visibilitystate_desktop">
      </div>
      <div class="column" id="visibilitystate_mobile">
      </div>
    </div>

    <h3 id="landingpage-aspect">Landing Page</h3>

      <p>
        The following graphs show how many navigations were to a site's <a href="https://techdocs.akamai.com/mpulse-boomerang/docs/whats-in-an-mpulse-beacon#debugging-info-and-timestamps">Landing Page</a>. 
      </p> 
      <p>
        A landing page is the first page a user visits during a new "session" on a given website. This does not always have to be the "homepage", as it can be any page of a site, as long as it is the first a user visits.
      </p>
      <p> 
        A session is typically (though not always) defined as a series of navigations separate by no more than 30 minutes (after 30 minutes, the session automatically ends and the next navigation starts a new session).
      </p>
      
    <div class="columns box">
      <div class="column" id="landingpage_desktop">
      </div>
      <div class="column" id="landingpage_mobile">
      </div>
    </div>


    <h3 id="spa-aspect">Multi vs Single Page Apps</h3>

        <p>
          The following graphs show the amount of (typical) "multi-page app" (MPA) loads versus "single-page app" (SPA) loads. 
          SPA navigations can be broken down into both Hard Navigations (the first navigation to the page) and Soft Navigations (in-page route changes). 
        </p> 
        
      <div class="columns box">
        <div class="column" id="spa_desktop">
        </div>
        <div class="column" id="spa_mobile">
        </div>
      </div>


  <h2 id="about">About RUM Insights</h2>
    <p>
      RUM Insights is intended to grow into a wide collection of default visualizations of the underlying RUM Archive data, updated once a month. 
      The current version is limited to just a few graphs for some key data. 
      If you have ideas about additional graphs or new features, let us know on <a href="https://github.com/rum-archive/rum-archive">GitHub</a>.
    </p>
    <p>
      The BigQuery queries used to generate data for these graphs and their outputs can be found in the separate <a href="https://github.com/rum-archive/rum-insights-data/tree/main/queries">rum-insights-data GitHub repository</a>.
    </p>


</section>

<script type="module">

    // import HighCharts from "/js/charts/timeseries.js";

    import { Constants } from "/js/charts/constants.js";
    import * as TimeSeries from "/js/charts/timeseries.js"; 
    import * as Donuts from "/js/charts/donuts.js";
    import * as Area from "/js/charts/area.js";

    // 3 colors with good contrast, since we often have piecharts with exactly 2 or 3 entries
    const piecolors = [ TimeSeries.Colors.RUMARCHIVE_MAIN[0], TimeSeries.Colors.RUMARCHIVE_MAIN[1], TimeSeries.Colors.RUMARCHIVE_SECONDARY[5] ];
    
    // returns e.g., "2023_12_01"
    function findLastDate(dataPoints) {
      // want to find the most recent datapoint in the file
      // for now, we don't actually parse the dates, but just assume the final entry in the list of dataPoints is part of the most recent batch
      if ( dataPoints && dataPoints.length > 0 && dataPoints[ dataPoints.length - 1].date ) {
        return dataPoints[ dataPoints.length - 1].date;
      }
      else {
        console.error("findLastDate: no 'date' property found on dataPoints, defaulting to 2024_07_02!", dataPoints);
        return "2024_07_02";
      }
    }

    function getDeviceTypeTimeseries(rumarchiveData, metricFieldName) {
      rumarchiveData = rumarchiveData.filter( datapoint => (parseFloat(datapoint.percent) > 1) );

      let output = [];

      // need to give the graphing setup a list of timeseries, each with their own data and color
      // we want to generate these automatically from the data
      // 1. extract individual metricFieldValues (e.g., extract all individual device types)
      let metricValues = new Set();
      for ( let row of rumarchiveData )
        metricValues.add( row[metricFieldName] );

      for ( let metricValue of metricValues ) {
        let timeSerie = {
          name: metricValue,
          data: rumarchiveData.filter( o => o[metricFieldName] === metricValue ),
          fields: ["percent"],
          color: (metricValue === "Desktop") ? TimeSeries.Colors.DESKTOP : ( (metricValue === "Mobile") ? TimeSeries.Colors.MOBILE : TimeSeries.Colors.TABLET )
        };

        output.push( timeSerie );
      }

      return output;
    }

    TimeSeries.fromDataWithDefaults( "devicetype", "marketshare_devicetypes", "device", "Device Type", getDeviceTypeTimeseries );
    // renderDeviceTypeTimeseries();


    async function renderOSTimeseries(clientType, chartId, chartName) {
        try {
          const metricFieldName = "os";
          const queryName = "os_devicetype";

          let response = await fetch( Constants.getDataURL(queryName) );
          let rumarchiveData = await response.json();
        
          rumarchiveData = rumarchiveData.filter( datapoint => (datapoint.client === clientType) && (parseFloat(datapoint.percent) > 0.5) );

          const options = {};
          options.chartId = chartId;
          options.histogram = { enabled: false };
          options.metric = metricFieldName;
          options.queryURL = Constants.getQueryURL(queryName);

          // need to give the graphing setup a list of timeseries, each with their own data and color
          // we want to generate these automatically from the data
          // 1. extract individual metricFieldValues (e.g., extract all individual device types)
          let metricValues = new Set();
          for ( let row of rumarchiveData )
            metricValues.add( row[metricFieldName] );

          let osColors = TimeSeries.Colors.LIST;

          options.timeseries = [];
          for ( const [idx, metricValue] of [...metricValues].entries() ) {
            let timeSerie = {
              name: metricValue,
              data: rumarchiveData.filter( o => o[metricFieldName] === metricValue ),
              fields: ["percent"],
              color: osColors[idx]
            };

            options.timeseries.push( timeSerie );
          }

          options.type = "%";

          options.id = "os";
          options.name = chartName;

          options.yMax = 100;

          TimeSeries.fromData(rumarchiveData, metricFieldName, options, rumarchiveData[0].date, rumarchiveData[rumarchiveData.length - 1].date );
        }
        catch(e) {
          console.error(e);
          return;
        }
    }
    
    renderOSTimeseries("desktop", "marketshare_os_desktop", "Desktop Operating System");
    renderOSTimeseries("mobile", "marketshare_os_mobile", "Mobile Operating System");


    async function renderBrowserPiechart(clientType, chartId, chartName) {
      const options = {};

      const metricFieldName = "useragent";

      const queryName = "LCPCount_useragentfamily_" + clientType;

      let response = await fetch( Constants.getDataURL(queryName) );
      let rumarchiveData = await response.json();

      // this data is a bit different:
      // - always contains only data for a single devicetype (no need to filter on device)
      // - split into two datasets: one with each individual browser, one with them grouped
      /*{
        "individual": [
          {"device":"desktop","date":"2023_09_01","cwvpercent":"0.1","useragentpercent":"0.0","useragent":"Chromium"}
        ],
        "grouped", [
          {"device":"desktop","date":"2023_09_01","useragentgroup":"Others","cwvpercent":"0.4","useragentpercent":"1.2"}
        ]
      }*/

      // normally, we need the individual measurements and use the "useragentpercent" as the value
      rumarchiveData = rumarchiveData.individual;

      rumarchiveData = rumarchiveData.filter( datapoint => (parseFloat(datapoint.useragentpercent) > 0.5) );

      let datapoints = rumarchiveData;
      // want to assign colors based on contribution: largest part gets the primary color, 2nd largest secondary color, etc.
      datapoints = datapoints.sort((a, b) => { return parseFloat(b["useragentpercent"]) - parseFloat(a["useragentpercent"]) } ); // desc sort
      datapoints = datapoints.map( (val, idx) => { val.color = TimeSeries.Colors.LIST[idx]; return val; } );

      options.chartId = chartId;
      options.name = chartName;
      options.queryURL = Constants.getQueryURL(queryName);

      options.datapoints = datapoints;
      options.datapointFieldname = "useragentpercent";

      Donuts.fromData( metricFieldName, options );

    }

    renderBrowserPiechart("desktop", "marketshare_browser_desktop", "Desktop browsers");
    renderBrowserPiechart("mobile", "marketshare_browser_mobile", "Mobile browsers");


    // Start: browser version select
    // This one is a bit different, in that we need to manually select a slicing of the data and make it update-able
    // to keep track of which one is currently selected, we use a global variable just to make it easy to access
    // (instead of having to go to the <select> with DOM every time)

    // we first load the data to be able to populate the <select> and auto-select the first one
    // NOTE: we rely on the data to be cached in the browser to prevent fetching again in TimeSeries.fromDataWithDefaults when the user changes selection!
    let GLOBAL_selectedUserAgent = "";

    async function loadUserAgentSelectOptions() {

      let response = await fetch( Constants.getDataURL("useragentversion_useragentfamily_devicetype") );
      let rumarchiveData = await response.json();
    
      // The raw data includes bots/outliers, meaning unexpected browsers show up for some platforms
      // for example, we have some dozens of page loads for "Chrome Mobile iOS" on desktop, which doesn't make sense
      // I manually went through all the platform + family combinations to see which had proper marketshare
      // the ones below do not, so we filter them here
      // Note: even on Mobile, Opera Mini has a tiny marketshare, so we skip it alltogether
      // TODO: this should probably happen during the processing step of the data in rum-insights-data instead :) 
      let skipSet = [];
      skipSet["desktop"] = [
        "Firefox Mobile",
        "Opera Mini",
        "Chrome Mobile WebView",
        "Chrome Mobile",
        "Chrome Mobile iOS",
        "Facebook",
      ];
      skipSet["mobile"] = [
        "Chrome",
        "Opera Mini",
        "Edge",
        "Safari",
      ];

      // need to extract the unique useragentfamily_devicetype values we have available
      // since browser names (.family) are not unique across platforms, we include the platform (.client) in the option ID
      // e.g., will be mobile_chrome
      let useragents = new Set();
      for( let row of rumarchiveData ) {
        // for now, we're not interested in Tablet numbers specifically, so leave them out 
        if( row.client === "tablet")
          continue;
        
        // skip browser if it's in the skipset manually defined above
        if ( skipSet[row.client].indexOf(row.family) >= 0 )
          continue;

        useragents.add( row.client + "_" + row.family );
      }

      useragents = Array.from( useragents ).sort(); // mainly to sort on platform

      const selectBox = document.getElementById("marketshare_browser_version_select");
      for ( let useragentkey of useragents ) {
        const option = document.createElement("option");
        const split = useragentkey.split("_");
        option.text = split[0][0].toUpperCase() + split[0].slice(1) + " : " + split[1];
        option.value = useragentkey;
        selectBox.add(option);
      }

      selectBox.addEventListener("change", (event) => {
        GLOBAL_selectedUserAgent = event.target.value;
        TimeSeries.fromDataWithDefaults( "useragentversion_useragentfamily_devicetype", "marketshare_browser_version", "version", GLOBAL_selectedUserAgent.split("_")[1] + " Versions", getUserAgentTimeSeries );
      });

      // load the default (first entry in the list)
      GLOBAL_selectedUserAgent =  useragents[0];
      TimeSeries.fromDataWithDefaults( "useragentversion_useragentfamily_devicetype", "marketshare_browser_version", "version", useragents[0].split("_")[1] + " Versions", getUserAgentTimeSeries );

    }

    loadUserAgentSelectOptions();

    // the JSON file from the server contains info for ALL browsers: need to filter based on what was actually selected. 
    function getUserAgentTimeSeries(rumarchiveData, metricFieldName) {
      const [deviceType, useragentFamily] = GLOBAL_selectedUserAgent.split("_");
      rumarchiveData = rumarchiveData.filter( datapoint => (parseFloat(datapoint.percent) > 1) );
      rumarchiveData = rumarchiveData.filter( datapoint => datapoint.family === useragentFamily && datapoint.client === deviceType );

      console.log("Showing user agent ", GLOBAL_selectedUserAgent, rumarchiveData);

      let output = [];

      // need to give the graphing setup a list of timeseries, each with their own data and color
      // we want to generate these automatically from the data
      // 1. extract individual metricFieldValues (e.g., extract all individual device types)
      let metricValues = new Set();
      for ( let row of rumarchiveData )
        metricValues.add( row[metricFieldName] );

      for ( const [idx, metricValue] of [...metricValues].entries() ) {
        let timeSerie = {
          name: metricValue,
          data: rumarchiveData.filter( o => o[metricFieldName] === metricValue ),
          fields: ["percent"],
          color: TimeSeries.Colors.LIST[idx]
        };

        output.push( timeSerie );
      }

      return output;
    }

    // BEGIN: BASELINE SUPPORT LOGIC

    async function populateBaselineInfo() {

      const responses = await Promise.all([
        fetch(Constants.getDataURL("recent_useragentversion_useragentfamily_devicetype")), 
        fetch(Constants.getDataURL("web-features")),
        fetch(Constants.getDataURL("baseline-browser-mappings"))
      ]);

      let ua_data       = await responses[0].json();
      let web_features  = await responses[1].json();
      let bcd_mappings  = await responses[2].json();

      // console.log( ua_data, web_features, bcd_mappings );

      // we want to create a baseline list for desktop vs mobile (which is what web-features gives us)
      // web-features is limited to:
      // Desktop: chrome, edge, firefox, safari
      // Mobile: chrome_android, firefox_android, safari_ios
    
      // so we filter out the accompanying ones from the RUM-archive for now (Untracked)
      // and map from RUMArchive names to web-features names to properly match (Tracked)
      // there are some gotchas in here to get the actual versions right (e.g., for Samsung Internet and Chrome Mobile), see later
      let desktopUAMappings = {
        "Chrome": "chrome",
        "Edge": "edge",
        "Firefox": "firefox",
        "Safari": "safari",

        // there is apparently a caveat with Linux, where Samsung Internet uses borked version numbers somehow?? Deal with that manually
        // TODO: just remove this entirely, since it's not supposed to be on Desktop (and non-linux has only 11 beacons in the initial dataset...)
        "Samsung Internet": "chrome",
        "Opera": "chrome",

        // "Chrome Mobile WebView": "chrome", // has some tiny presence on Desktop, probably bots etc. // best to not track though
      };

      let mobileUAMappings = {
        "Chrome": "chrome_android", // on Android OS, it's categorized as "Chrome" instead of "Chrome Mobile" by RUM Archive
        "Chrome Mobile": "chrome_android",
        "Chrome Mobile WebView": "chrome_android",
        "Firefox Mobile": "firefox_android",

        "Mobile Safari": "safari_ios",
        "Mobile Safari UI/WKWebView": "safari_ios",
        "Chrome Mobile iOS": "safari_ios", // all browsers on iOS are actually webkit under the hood
        "Firefox iOS": "safari_ios", // all browsers on iOS are actually webkit under the hood

        // "Edge Mobile": "mixed_chrome_safari", // this is a weird one... shows up both on Android and iOS, and needs split handling, so separate category is needed
        "Facebook": "mixed_chrome_safari",
        "Instagram": "mixed_chrome_safari", 

        "Samsung Internet": "chrome_android",
        "Opera Mobile": "chrome_android",
        // this is the Google Search App
        "Google": "safari_ios" // confirmed manually that this UA is only seen on iOS, so can treat this just as "Chrome Mobile iOS" (according to Google engineers)
      };

      let thingsThatAreActuallyWebkit = ["Chrome Mobile iOS", "Firefox iOS", "Google", "Facebook", "Instagram"];

      // create easy to use lookup arrays
      let desktopUAs  = Object.keys(desktopUAMappings);
      let mobileUAs   = Object.keys(mobileUAMappings);

      // want to keep details on which User Agents are tracked and which usage % they represent to show in the UI later
      let unknownUAsWithCounts = {};
      let knownUAsWithCounts = {};

      // to calculate percentages, need to know total beacon counts per platform for a given day
      // we want two different running counts, 1 for the Tracked browsers in desktopUAs and mobileUAs, and one for ALL browsers (including Untracked)
      let totalDesktopCount_subset = 0;
      let totalMobileCount_subset = 0;
      let totalDesktopCount_all = 0;
      let totalMobileCount_all = 0;

      for( let datapoint of ua_data ){

        let uaName = datapoint.family;
        let clientType = datapoint.client === "desktop" ? datapoint.client : "mobile"; // for mobile, we have both mobile and tablet in the RUMArchive, which need to be treated the same

        let uaKey = clientType + "_" + uaName;
        let dictionaryToUse = null;

        if ( datapoint.client === "desktop" ){
          
          // MANUAL OVERRIDE
          // there is apparently a caveat with Linux, where Samsung Internet uses borked version numbers somehow?? Deal with that manually
          if ( datapoint.family === "Samsung Internet" && datapoint.os === "Linux" ){
            // normally, SI is tracked, but here we treat it as untracked
            dictionaryToUse = unknownUAsWithCounts;
          }
          else if ( desktopUAs.includes(datapoint.family)  ) {
            totalDesktopCount_subset += datapoint.count;
            dictionaryToUse = knownUAsWithCounts;
          }
          else {
            dictionaryToUse = unknownUAsWithCounts;
          }
          
          totalDesktopCount_all += datapoint.count; 
        }

        // for the purpose of Baseline, mobile and tablet are treated the same, 
        // since they use the same browsers (e.g., Chrome iOS is the same on iPhone as iPad)
        else if ( datapoint.client === "mobile" || datapoint.client === "tablet" ){

          if ( (datapoint.family === "Facebook" || datapoint.family === "Instagram") && datapoint.os !== "iOS" ){
            // console.error("FB or Insta on non-IOS detected", datapoint);
            // Facebook and Instagram are only tracked on iOS
            dictionaryToUse = unknownUAsWithCounts;
          }
          else if ( mobileUAs.includes(datapoint.family) ) {
            totalMobileCount_subset += datapoint.count;
            dictionaryToUse = knownUAsWithCounts;
          }
          else {
            dictionaryToUse = unknownUAsWithCounts;
          }
          
          totalMobileCount_all += datapoint.count; 
        }

        let uaTracker = dictionaryToUse[ uaKey ];
        if ( !uaTracker ) {
          uaTracker = { key: uaKey, ua: uaName, clientType: clientType, count: 0, osinfo: new Set() };
          dictionaryToUse[ uaKey ] = uaTracker;
        }
        uaTracker.count += datapoint.count;
        uaTracker.osinfo.add( datapoint.version + "@" + datapoint.os + "_" + datapoint.osversion );
      }

      // console.log("Beacon Counts: (subset, all, diff)", totalDesktopCount_subset, totalDesktopCount_all, (totalDesktopCount_all - totalDesktopCount_subset), totalMobileCount_subset, totalMobileCount_all, (totalMobileCount_all - totalMobileCount_subset), ((totalMobileCount_all - totalMobileCount_subset)/totalMobileCount_all * 100).toFixed(2)  );

      // calculate usage percentages for both known and unknown UAs
      for( let uaEntry of Object.entries(knownUAsWithCounts) ) {
        let ua = uaEntry[1];

        if ( ua.clientType === "desktop" ) {
          ua.percentage_raw = (ua.count / totalDesktopCount_all) * 100;
          ua.percentage = ua.percentage_raw.toFixed(4) + "%";
        }
        else {
          ua.percentage_raw = (ua.count / totalMobileCount_all) * 100;
          ua.percentage = ua.percentage_raw.toFixed(4) + "%";
        }
      }

      for( let uaEntry of Object.entries(unknownUAsWithCounts) ) {
        let ua = uaEntry[1];

        if ( ua.clientType === "desktop" ) {
          ua.percentage_raw = (ua.count / totalDesktopCount_all) * 100;
          ua.percentage = ua.percentage_raw.toFixed(4) + "%";
        }
        else {
          ua.percentage_raw = (ua.count / totalMobileCount_all) * 100;
          ua.percentage = ua.percentage_raw.toFixed(4) + "%";
        }
      }

      knownUAsWithCounts = Object.values(knownUAsWithCounts).sort( (a,b) => b.percentage_raw - a.percentage_raw ).map( (a) => { a.osinfo = Array.from(a.osinfo); return a; } );
      unknownUAsWithCounts = Object.values(unknownUAsWithCounts).sort( (a,b) => b.percentage_raw - a.percentage_raw ).map( (a) => { a.osinfo = Array.from(a.osinfo); return a; } );

      // console.log("Known UAs with counts:", knownUAsWithCounts);
      // console.log("Unknown UAs with counts:", unknownUAsWithCounts);

      // use a global to make this easily accessible from showUsageDisclaimer
      // TODO: refactor global use ;) 
      window.uas = {};
      window.uas.known = knownUAsWithCounts;
      window.uas.unknown = unknownUAsWithCounts;

      // 1. per year, we need a list of features that were added to the baseline in that year with links (that's easy though)
      // 2. per year, we need a total COUNT of how many beacons belong to browsers whose version were >= versions that started to support that feature

      // 1.
      let baselineResults = [
        { clients: ["desktop"], uas: desktopUAs, uamappings: desktopUAMappings, totalCount: totalDesktopCount_subset, yearCounts: [] },
        { clients: ["mobile","tablet"], uas: mobileUAs, uamappings: mobileUAMappings, totalCount: totalMobileCount_subset, yearCounts: [] },
      ];

      let baselineFeaturesPerYear = {};
      for( let year = 2017; year <= 2024; year++ ) {
        let yearFeatures = [];
        // baseline dates are for the baseline_low_date (means low availability, but year is correct)
        for ( let web_feature of Object.values(web_features) ) {
          if ( web_feature.status && web_feature.status.baseline_low_date ) {
            let featureYear = web_feature.status.baseline_low_date.split("-")[0]; // format: 2023-05-09
            if ( featureYear === ("" + year) ){
              yearFeatures.push( web_feature );
            }
          }
          else if( web_feature.status && web_feature.status.baseline !== false ) {
            console.warn("SANITY CHECK: web feature doesn't have baseline_low_date yet!", web_feature);
          }
          else if ( !web_feature.status ) {
            // console.error("SANITY CHECK: web feature doesn't have status yet!", web_feature);
            // APPARENTLY there are a great many features without a status yet... just skip them for now 
          }
        }

        baselineFeaturesPerYear["" + year] = yearFeatures;
      }

      // 2.
      for( let baselineEntry of baselineResults ) { // desktop vs mobile
        const clients = baselineEntry.clients;
        const uas = baselineEntry.uas;
        const uamappings = baselineEntry.uamappings;
        const resultsPerYear = baselineEntry.yearCounts;

        for( let year = 2017; year <= 2024; year++ ){

          if ( !resultsPerYear[""+year] ) {
            resultsPerYear[""+year] = 0;
          }

          const featuresForCurrentYear = baselineFeaturesPerYear["" + year];

          // for now, we just need a running total count of beacons that we saw that are >= a given version, don't really need to keep detailed results
          // so we just loop over each version for each browser for each client type, and for each check if it's >= the year's expected versions for each webFeature

          for( let datapoint of ua_data ){

            let clientType = datapoint.client === "desktop" ? "desktop" : "mobile";

            if ( datapoint.family === "Samsung Internet" && datapoint.os === "Linux" ){
              // normally, SI is tracked, but here we treat it as untracked because it has weird things in the versions that we can't resolve
              continue;
            }

            if ( (datapoint.family === "Facebook" || datapoint.family === "Instagram") && datapoint.os !== "iOS" ){
              // FB and Insta are only tracked on iOS. Otherwise, we need to ignore them for calculating these support percentages
              continue;
            }

            if ( clients.includes(datapoint.client) && uas.includes(datapoint.family) ) {
              // for a given browser version entry, we need to see for ALL baseline features in that year if it's supported
              // this because e.g., a browser version could have gone live in July 202x but the baseline feature was only completed in the baseline in November 202x
              // We could theoretically also get this from the full baseline_low_date, but then we'd also need to know the release dates of all browser versions, which we don't :)
              // so: just check if we pass the version check for all of the webFeatures and only then add it to the resultsPerYear

              let passesAll = true; // assume yes
              for( let webFeature of featuresForCurrentYear ) {
                
                if( !webFeature.status ) {
                  console.error("SANITY CHECK: NO STATUS KNOWN, WHY NOT?!?", webFeature);
                }

                // TODO: move all this logic outside of this "per webfeature" loop instead!
                // some browsers don't have a direct mapping from RUM Archive UA to web-features UA and need special handling
                let uamapping = uamappings[datapoint.family];

                if ( uamapping === "mixed_chrome_safari" ) {
                  if ( datapoint.os === "iOS" ) {
                    uamapping = "safari_ios"; // treated as a webkit browser on iOS
                  }
                  else {
                    break;
                  }
                }

                let webFeatureUAVersion = webFeature.status.support[ uamapping ];
                if ( webFeatureUAVersion ) {
                  let rumArchiveVersionRaw = datapoint.version;

                  // some browsers are really something else under the hood (e.g., Opera is really Chrome/Blink)
                  // these browsers use their own version numbers (e.g., Samsung Internet v25.0 is Blink v121 internally)
                  // we need to convert from the RUM Archive version numbers to the engine version numbers, using bcd_mappings
                  if ( bcd_mappings[ clientType ] && bcd_mappings[clientType][datapoint.family] ) {
                    const bcd_versionmaps = bcd_mappings[clientType][datapoint.family].versions;
                    // in some cases, we'll see a version of the UA that's not in the bcd data (e.g., from an attacker/bot, or just missing data)
                    // in those cases, we just ignore that datapoint here
                    let guessedVersion = bcd_versionmaps[ rumArchiveVersionRaw ];
                    if( !guessedVersion ) {
                      // sometimes the lookup expects v 16.0 instead of v 16, so try that as well
                      guessedVersion = bcd_versionmaps[ rumArchiveVersionRaw + ".0" ];

                      if ( !guessedVersion ) {
                        // console.warn("Browser version didn't have a proper BCD mapping, unexpected: ", datapoint.family, rumArchiveVersionRaw, bcd_versionmaps);
                        continue;
                      }
                    }
                    
                    if ( guessedVersion ) {
                      // console.log("Transforming versions via BCD: ", datapoint.family, rumArchiveVersionRaw, guessedVersion);
                      rumArchiveVersionRaw = guessedVersion;
                    }
                  }

                  // some browsers have their own version numbers, but are actually something else under the hood
                  // this is mainly iOS browsers, which map to their WebKit versions defined by the OS version rather than the browser version
                  // i.e., Chrome Mobile v122 on iOS 17.3 should ACTUALLY be counted as Safari 17.3 
                  // so we use the OSVersion for those type of browser instead
                  if( clientType === "mobile" && thingsThatAreActuallyWebkit.includes(datapoint.family) ){
                    rumArchiveVersionRaw = datapoint.osversion;
                    // console.error("DEBUG: MAPPING WEBKIT MANUALLY", datapoint.family, datapoint.version, datapoint.osversion );
                  }

                  // Safari has subversions as part of the version string (i.e., 16.7)
                  // all other browsers only have integer versions
                  // just using a parse to float should work on both types (integers will just get .0)
                  let baselineVersionFloat = parseFloat(webFeatureUAVersion, 10);
                  let rumArchiveVersionFloat = parseFloat(rumArchiveVersionRaw, 10);

                  if ( rumArchiveVersionFloat < baselineVersionFloat ) {  
                    // console.warn("Feature was too new!", year, datapoint.family, datapoint.os, uamappings[datapoint.family], rumArchiveVersionFloat, "<", baselineVersionFloat, webFeature.name, (parseInt(datapoint.count) / baselineEntry.totalCount ) * 100 );
        
                    passesAll = false;
                    break; // we already know we failed, so we can do an early exit 
                  }
                }
                else {
                  console.error("SANITY CHECK: current ua not known in web-features...", datapoint.family, uamappings[datapoint.family], webFeature.status.support );
                }
              }

              if ( passesAll ) {
                resultsPerYear["" + year] += parseInt(datapoint.count); 
              }
            }
          }
        }
      }

      for( let baselineResult of baselineResults ) {
        let outputTable = document.getElementById("baseline_"+ baselineResult.clients[0] +"_table").getElementsByTagName('tbody')[0];

        for ( let year of Object.keys(baselineResult.yearCounts) ) {
          let counts = baselineResult.yearCounts[year];
          let percentage_subset = ((counts/baselineResult.totalCount) * 100).toFixed(2);

          let percentage_all = 0;
          let percentage_raw = 0;
          if ( baselineResult.clients[0] === "mobile" ) {
            percentage_raw = ((counts/totalMobileCount_all) * 100);
            percentage_all = ((counts/totalMobileCount_all) * 100).toFixed(2);
            // console.log(baselineResult.clients[0] + " - ALL ", year, counts, "out of", totalMobileCount_all, "=", percentage_all );
          }
          else {
            percentage_raw = ((counts/totalDesktopCount_all) * 100);
            percentage_all = ((counts/totalDesktopCount_all) * 100).toFixed(2);
            // console.log(baselineResult.clients[0] + " - ALL ", year, counts, "out of", totalDesktopCount_all, "=", percentage_all );
          }

          // console.log("Subset ", year, counts, "out of", baselineResult.totalCount, "=", percentage_subset );

          let yearRow = outputTable.insertRow();
          yearRow.setAttribute("baseline-year", year + "_" + percentage_subset);

          let yearCell = document.createElement("th");
          yearRow.appendChild(yearCell);
          let resultCell = yearRow.insertCell(1);


          yearCell.innerHTML = "" + year;
          yearCell.style = "text-align: center;";
          resultCell.style = "text-align: center;";
          resultCell.innerHTML = "" + percentage_subset + "%";
        }

        outputTable.addEventListener("click", (evt) => {
          if ( !evt.target )
            return;

          // the click is usually the year <th> or the percentage <td>
          // we need to get parent tr if that's the case
          let row = evt.target;
          let yearPercent = evt.target.getAttribute("baseline-year");

          if ( !yearPercent && evt.target.parentNode ){
            yearPercent = evt.target.parentNode.getAttribute("baseline-year");
            row = evt.target.parentNode;
          }

          if ( !yearPercent ){ // can't find the baseline-year... nothing left to do
            console.error("outputTable:click : can't find the baseline-year... can't proceed", evt.target, evt.target.getAttribute("baseline-year"), evt);
            return;
          }
          
          // make sure old element is deselected
          const currentlySelected = outputTable.getElementsByClassName("is-selected");
          for ( let cs of currentlySelected ) {
            cs.classList.remove("is-selected");
          }

          // select current row
          row.classList.add("is-selected");
          
          const year = yearPercent.split("_")[0];
          const percentage = yearPercent.split("_")[1];

          let detailsContainer = document.getElementById("baseline_"+ baselineResult.clients[0] +"_details");
          detailsContainer.getElementsByTagName("h4")[0].textContent = "Details for Baseline " + year;

          if ( parseInt(year) <= 2022 ) {
            // at the time of writing, we only have full features for 2023 and 2024
            // as such, for anything 2022 and below, we still want to show the percentages, but not the individual feature lists, because they're incomplete

            let detailsContent = `
              <p>
                For the users represented in the RUM Archive, <b>${percentage}%</b> of ${baselineResult.clients[0]} visitors used a 
                Tracked browser <img class="usageDisclaimerIcon" onclick="showUsageDisclaimer('${baselineResult.clients[0]}')" src="/assets/question_mark.png" /> 
                version released after January 1st ${parseInt(year) + 1}, meaning they should support all features in Baseline ${year} and below.
                Consider this the lower bound. 
              </p>
              <p>
                For the time being, we do not have a full list of features for Baseline ${year}. 
                This is because we are dependent on the <a href="https://github.com/web-platform-dx/web-features">Web Features Project</a>, 
                which is still hard at work backfilling the details for years prior to 2023.
              </p>
              <p>
                For now, select 2023 or 2024 for more in-depth info on which features are included in those Baselines. 
                Check back here later for more details for earlier years as they become available. 
              </p>
            `;

            let textContainer = detailsContainer.getElementsByTagName("div")[0];
            textContainer.innerHTML = detailsContent;

            return;
          }

          let detailsContent = `If you target the following Web features for Baseline ${year}, <b>` + percentage + `%</b> of `+ baselineResult.clients[0] +` users in the RUM Archive for the Tracked browsers <img class="usageDisclaimerIcon" onclick="showUsageDisclaimer('${baselineResult.clients[0]}')" src="/assets/question_mark.png" /> would benefit:<br /><br />`;

          // we want to group compat features by type (CSS, JS, HTML, API, Other)
          let groups = {
            "css": new Set(),
            "javascript": new Set(),
            "html": new Set(),
            "api": new Set(),
            "http": new Set(),
            "svg": new Set(),
            "other": new Set(),
          };

          // we want the groups to display properly capitalized etc.
          let groupNames = {
            "css": "CSS",
            "javascript": "JavaScript",
            "html": "HTML",
            "api": "APIs",
            "http": "HTTP",
            "svg": "SVG",
            "other": "Others",
          };

          for ( let feature of baselineFeaturesPerYear[year] ) {
            let compat_features = feature.compat_features;
            if( compat_features ){

              // compat_features can have multiple subfeatures listed, each belonging to a specific group
              // e.g., you can have 
              // [ "api.feature.1", "api.feature.2", "html.feature.x", "html.feature.y" ]
              // we only want to show the feature ONCE under a group (so for the example, we don't want to show both in API AND HTML, but only HTML)
              // so, we can't just look at the first one in the list, because APIs are a bit special
              // (most features will have an API subfeature... if there is any other grouping possible (e.g., HTML in the example) then that should be preferred)
              // so, we special-case api.

              // check if all compat_features are in the same feature group
              let guessedGroup = null;
              let hasAPIgroup = false;
              for ( let compat_feature of compat_features ){ 
                let currentGroup = compat_feature.split(".")[0]; 

                if ( currentGroup === "api" )
                  hasAPIgroup = true;
                else if( guessedGroup === null )
                  guessedGroup = currentGroup;
                else if ( guessedGroup !== currentGroup ) {
                  // some features are known to be inconsistent and we hardcode their mappings here for now
                  if( feature.name === "Popover" ){
                    guessedGroup = "html";
                  }
                  else if (feature.name === "<dialog>") {
                    guessedGroup = "html";
                  }
                  else 
                    console.error("INCONSISTENT compat_features! ", currentGroup, "!=", guessedGroup, compat_features, feature);
                }
              }

              if ( guessedGroup === null ) {
                // no group found. Could mean 1 of 2 things
                // 1. it is really an API feature: put into that group
                // 2. it simply doesn't have a known group: put it as "other"
                if ( hasAPIgroup ) {
                  guessedGroup = "api";
                }
                else {
                  guessedGroup = "other";
                }
              }

              if ( !Object.keys(groups).includes(guessedGroup) ) {
                console.warn("New feature group found that we didn't know about yet! Putting it as 'other' for now", guessedGroup, feature);
                guessedGroup = "other";
              }

              groups[guessedGroup].add( feature );
            }
            else {
              // e.g., AVIF support doesn't have compat_features
              groups["other"].add( feature );
            }
          }

          // console.log( groups );

          for ( let group of Object.entries(groups) ) {
            if( group[1].size === 0 )
              continue;

            detailsContent += "<h5>" + groupNames[ group[0] ] + "</h5><ul class=\"features-list\">";

            for ( let feature of group[1] ) {

              // some feature's name is a valid HTML element tag... LOOKING AT YOU <detail>... urgh
              let name = feature.name.replaceAll('<', '&lt;').replaceAll('>', '&gt;');

              // not everythin has a caniuse slag sadly...
              // one way to work around that is to construct a caniuse from the first compat_features indicator
              let link = "https://caniuse.com/";
              if ( feature.caniuse ){
                link += feature.caniuse;
              }
              else if ( feature.compat_features && feature.compat_features.length > 0 ) {
                // if the compat_features[0] is this: javascript.builtins.Array.fromAsync
                // then the caniuse slug should be this: mdn-javascript_builtins_array_fromasync
                
                let slug = feature.compat_features[0].toLowerCase().replaceAll(".","_");

                link += `mdn-${ slug }`;

                // console.log("Feature without caniuse... trying to map directly via compat_features", link, feature);
              }
              else if ( feature.spec ) {
                link = feature.spec;
              }
              else {
                link = undefined;
                console.error("Could not generate a link for feature... shouldn't happen: ", feature);
              }

              if ( link )
                detailsContent += `<li><a href="${link}" target="_blank">${name}</a></li>`;
              else
                detailsContent += `<li>${name}</li>`
            }

            detailsContent += "</ul>"
          }

          let textContainer = detailsContainer.getElementsByTagName("div")[0];
          textContainer.innerHTML = detailsContent;
        });
      }

      console.log( baselineResults );
    }

    populateBaselineInfo();


    // END: BASELINE SUPPORT LOGIC



    


    // TODO: inject another graph that shows useragentpercent grouped (for perfnow) and maybe ungrouped cwvpercent as well (first that, then grouped for better understanding)

    
    

    async function renderNavigationTypePiechart(clientType, chartId, chartName) {
      const options = {};

      const metricFieldName = "navigationtype";

      const queryName = "navigationtype_devicetype";

      let response = await fetch( Constants.getDataURL(queryName) );
      let rumarchiveData = await response.json();

      const valueKey = "percent";

      // the dataset contains data for each month, but for the piechart here, we only want to latest
      const date = findLastDate(rumarchiveData);
      let datapoints = rumarchiveData.filter( point => point.date == date && point.client == clientType );

      // want to assign colors based on contribution: largest part gets the primary color, 2nd largest secondary color, etc.
      datapoints = datapoints.sort((a, b) => { return parseFloat(b[valueKey]) - parseFloat(a[valueKey]) } ); // desc sort
      datapoints = datapoints.map( (val, idx) => { val.color = piecolors[idx]; return val; } );

      options.chartId = chartId;
      options.name = chartName;
      options.datapoints = datapoints;
      options.datapointFieldname = valueKey;
      options.queryURL = Constants.getQueryURL(queryName);

      Donuts.fromData( metricFieldName, options );
    }

    renderNavigationTypePiechart("desktop", "navigationtype_desktop", "Navigation Types (Desktop)");
    renderNavigationTypePiechart("mobile", "navigationtype_mobile", "Navigation Types (Mobile)");

    async function renderVisibilityStatePiechart(clientType, chartId, chartName) {
      const options = {};

      const metricFieldName = "visibilitystate";
      const queryName = "visibilitystate_devicetype";

      let response = await fetch( Constants.getDataURL(queryName) );
      let rumarchiveData = await response.json();

      const valueKey = "percent";

      // the dataset contains data for each month, but for the piechart here, we only want to latest
      const date = findLastDate(rumarchiveData);
      let datapoints = rumarchiveData.filter( point => point.date == date && point.client == clientType );

      // want to assign colors based on contribution: largest part gets the primary color, 2nd largest secondary color, etc.
      datapoints = datapoints.sort((a, b) => { return parseFloat(b[valueKey]) - parseFloat(a[valueKey]) } ); // desc sort
      datapoints = datapoints.map( (val, idx) => { val.color = piecolors[idx]; return val; } );

      options.chartId = chartId;
      options.name = chartName;
      options.datapoints = datapoints;
      options.datapointFieldname = valueKey;
      options.queryURL = Constants.getQueryURL(queryName);

      Donuts.fromData( metricFieldName, options );
    }

    renderVisibilityStatePiechart("desktop", "visibilitystate_desktop", "Visibility States (Desktop)");
    renderVisibilityStatePiechart("mobile", "visibilitystate_mobile", "Visibility States (Mobile)");

    async function renderLandingPagePiechart(clientType, chartId, chartName) {
      const options = {};

      const metricFieldName = "landingpage";
      const queryName = "landingpage_devicetype";

      let response = await fetch( Constants.getDataURL(queryName) );
      let rumarchiveData = await response.json();

      const valueKey = "percent";

      // the dataset contains data for each month, but for the piechart here, we only want to latest
      const date = findLastDate(rumarchiveData);
      let datapoints = rumarchiveData.filter( point => point.date == date && point.client == clientType );

      // want to assign colors based on contribution: largest part gets the primary color, 2nd largest secondary color, etc.
      datapoints = datapoints.sort((a, b) => { return parseFloat(b[valueKey]) - parseFloat(a[valueKey]) } ); // desc sort
      datapoints = datapoints.map( (val, idx) => { val.color = piecolors[idx]; return val; } );

      options.chartId = chartId;
      options.name = chartName;
      options.datapoints = datapoints;
      options.datapointFieldname = valueKey;
      options.queryURL = Constants.getQueryURL(queryName);

      Donuts.fromData( metricFieldName, options );
    }

    renderLandingPagePiechart("desktop", "landingpage_desktop", "Landing Page (Desktop)");
    renderLandingPagePiechart("mobile", "landingpage_mobile", "Landing Page (Mobile)");


    async function renderBeaconTypePiechart(clientType, chartId, chartName) {
      const options = {};

      const metricFieldName = "beacontype";
      const queryName = "beacontype_devicetype";

      let response = await fetch( Constants.getDataURL(queryName) );
      let rumarchiveData = await response.json();

      const valueKey = "percent";

      // the dataset contains data for each month, but for the piechart here, we only want to latest
      const date = findLastDate(rumarchiveData);
      let datapoints = rumarchiveData.filter( point => point.date == date && point.client == clientType );

      // TODO: allow bfcache if the amount picks up (right now, only 0.1% max, looks weird)
      datapoints = datapoints.filter( point => point.beacontype !== "bfcache" );

      // want to assign the same colors to the same thing, even if the distributions are different, so have to do that manually
      datapoints = datapoints.sort((a, b) => { return parseFloat(b[valueKey]) - parseFloat(a[valueKey]) } ); // desc sort
      // datapoints = datapoints.map( (val, idx) => { val.color = piecolors[idx]; return val; } );

      const mpa = datapoints.filter( p => p.beacontype === "page view" )[0];
      mpa.color = piecolors[0];
      mpa.beacontype = "MPA";

      const spah = datapoints.filter( p => p.beacontype === "spa" )[0];
      spah.color = piecolors[1];
      spah.beacontype = "SPA (hard)";

      const spas = datapoints.filter( p => p.beacontype === "spa hard" )[0];
      spas.color = piecolors[2];
      spas.beacontype = "SPA (soft)";

      // datapoints.filter( p => p.beacontype === "bfcache" )[0].color = TimeSeries.Colors.RUMARCHIVE_BLUE_2;

      options.chartId = chartId;
      options.name = chartName;
      options.datapoints = datapoints;
      options.datapointFieldname = valueKey;
      options.queryURL = Constants.getQueryURL(queryName);

      Donuts.fromData( metricFieldName, options );
    }

    renderBeaconTypePiechart("desktop", "spa_desktop", "MPA vs SPA (Desktop)");
    renderBeaconTypePiechart("mobile", "spa_mobile", "MPA vs SPA (Mobile)");

</script>

<script>

    // had to put this inside a separate script tag (that's NOT a module) so the button onclick event handlers in the HTML could find the function
    // TODO: fix this properly somehow
    function showUsageDisclaimer(clientType) {
      // make sure any currently selected rows in the output table is deselected

      let featuresTable = document.getElementById("baseline_"+ clientType +"_table").getElementsByTagName('tbody')[0];
      
      // make sure old element is deselected
      const currentlySelected = featuresTable.getElementsByClassName("is-selected");
      for ( let cs of currentlySelected ) {
        cs.classList.remove("is-selected");
      }

      let detailsContainer = document.getElementById("baseline_"+ clientType +"_details");
      detailsContainer.getElementsByTagName("h4")[0].textContent = "Disclaimer about usage tracking";

      let percentage_noise = 0.0;
      let percentage_tracked = 0.0;
      let unknownText = "";
      let knownText = "";

      for ( let ua of window.uas.unknown ) {
        if ( ua.clientType !== clientType )
          continue;

        percentage_noise += ua.percentage_raw;

        let uaName = ua.ua;

        // FB and Insta are Tracked for iOS but not for Android at this point. Make this clearer, as they are in both lists ;) 
        if ( clientType === "mobile" && uaName === "Facebook" ) {
          uaName = "Facebook (Android)";
        }
        else if ( clientType === "mobile" && uaName === "Instagram" ) {
          uaName = "Instagram (Android)";
        }

        unknownText += `<li> ${uaName} : ${ ua.percentage_raw.toFixed(4) }% (${ ua.count} beacons) </li>`;
      }

      for ( let ua of window.uas.known ) {
        if ( ua.clientType !== clientType )
          continue;

        percentage_tracked += ua.percentage_raw;

        let uaName = ua.ua;

        // FB and Insta are Tracked for iOS but not for Android at this point. Make this clearer, as they are in both lists ;) 
        if ( clientType === "mobile" && uaName === "Facebook" ) {
          uaName = "Facebook (iOS)";
        }
        else if ( clientType === "mobile" && uaName === "Instagram" ) {
          uaName = "Instagram (iOS)";
        }

        knownText += `<li> ${uaName} : ${ ua.percentage_raw.toFixed(4) }% (${ ua.count} beacons) </li>`;
      }

      // TODO: for mobile, 100 - percentage_noise is exactly equal to percentage_tracked
      // However, for desktop, there's a small discrepancy of like 0.1% that I can't figure out
      // so todo is: figure that out :) for now, to not cause confusion, just do this instead:
      percentage_tracked = 100 - percentage_noise;

      let detailsText = 
          `<p>
              We do not track feature support for every browser/User Agent. Some browsers are too old, or the information is not public, 
              or they are bots/attacker traffic, which is present in the RUM Archive data but impossible to automatically filter out. 
              The main results displayed in this table intentionally only take into account the tracked/known browsers and ignore the rest. 
            </p>
            <p>
              For the current date, the unknown browsers account for <b>${ percentage_noise.toFixed(2) }%</b> of total ${clientType} beacons seen.
              This means that ${percentage_tracked.toFixed(2)}% of all RUM beacons belong to a tracked browser. 
              Put differently, if the table on the left shows 100% baseline support, it means that <i>at least</i> ${percentage_tracked.toFixed(2)}% of all the considered 
              RUM Archive beacons were from browser types and versions that had support for those Baseline features. 
              That does not mean that the remaining User Agents don't support a feature, it simply means that we can't tell whether they do or not.
            </p>

            <p>
              Below you can find a detailed list of the usage share of each browser (both Tracked and Untracked).
            </p>
           `;

        for ( let ua of window.uas.unknown ) {
          if ( ua.clientType === clientType )
            percentage_noise += ua.percentage_raw;
        }

        detailsText += `
          <details>
            <summary>Tracked User Agents for ${clientType}</summary>
            <ul>${knownText}</ul>
          </details>
          <br />
          <details>
            <summary>Untracked User Agents for ${clientType}</summary>
            <ul>${unknownText}</ul>
            <p>Note: some of these User Agents might seem at first glance like they could be tracked (e.g., named after one of the main browsers), 
              but these often show up in impossible combinations (e.g., Chrome Mobile on Windows Desktop) and are likely bots that we intentionally exclude.
          </details>
        `;

      detailsText += `
        <br/>
        <p>Note that the RUM Archive uses <a href="https://github.com/ua-parser/">the ua-parser</a> project to parse User Agent strings. 
      `

      let textContainer = detailsContainer.getElementsByTagName("div")[0];
      textContainer.innerHTML = detailsText;
    }

</script>

        </div>
      </div>
    </div>
  </div>
</article>

  </main>
  <footer class="footer">
    <div class="content has-text-centered">
      <p>
        Sponsored by <a href="https://akamai.com">Akamai</a>.
        The website content is licensed
        <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.
      </p>
      <p>
        <a href="https://twitter.com/RUMArchive">twitter</a> -
        <a rel="me" href="https://webperf.social/@rumarchive">mastodon</a>
      </p>
    </div>
  </footer>
</body>
</html>
